// AgentController.ts

/** REFERENCE ONLY
 * Agent controller with lifecycle management, pause/resume, and session persistence.
 */

import { AgentBackend, AgentMessage, ClaudeCodeBackend, MessageType } from "pentestgpt/core/backend";
import { PentestGPTConfig } from "pentestgpt/core/config";
import { Event, EventBus, EventType } from "pentestgpt/core/events";
import { SessionStatus, SessionStore, Session } from "pentestgpt/core/session";

export enum AgentState {
    IDLE = "idle",
    RUNNING = "running",
    PAUSED = "paused",
    COMPLETED = "completed",
    ERROR = "error",
}

export class AgentController {
    // Flag detection patterns
    static FLAG_PATTERNS: string[] = [
        /flag\{[^\}]+\}/i,        // flag{...}
        /HTB\{[^\}]+\}/i,          // HTB{...}
        /CTF\{[^\}]+\}/i,          // CTF{...}
        /[A-Za-z0-9_]+\{[^\}]+\}/, // Generic CTF format
        /\b[a-f0-9]{32}\b/i,       // 32-char hex (HTB user/root flags)
    ];

    config: PentestGPTConfig;
    backend?: AgentBackend;
    sessions: SessionStore;
    events: EventBus;

    private _state: AgentState = AgentState.IDLE;
    private _pauseRequested = false;
    private _stopRequested = false;
    private _resumePromise?: { resolve: () => void };
    private _pendingInstruction?: string;

    constructor(
        config: PentestGPTConfig,
        backend?: AgentBackend,
        sessionStore?: SessionStore,
        events?: EventBus
    ) {
        this.config = config;
        this.backend = backend;
        this.sessions = sessionStore ?? new SessionStore();
        this.events = events ?? EventBus.get();

        // Subscribe to events
        this.events.subscribe(EventType.USER_COMMAND, this._onUserCommand.bind(this));
        this.events.subscribe(EventType.USER_INPUT, this._onUserInput.bind(this));
    }

    get state(): AgentState {
        return this._state;
    }

    private _setState(state: AgentState, details = ""): void {
        this._state = state;
        this.events.emitState(state, details);
    }

    // === Control Methods ===
    pause(): boolean {
        if (this._state === AgentState.RUNNING) {
            this._pauseRequested = true;
            return true;
        }
        return false;
    }

    resume(instruction?: string): boolean {
        if (this._state === AgentState.PAUSED) {
            this._pendingInstruction = instruction;
            this._pauseRequested = false;
            this._resumePromise?.resolve();
            return true;
        }
        return false;
    }

    stop(): boolean {
        this._stopRequested = true;
        this._resumePromise?.resolve(); // Unblock if paused
        return true;
    }

    inject(instruction: string): boolean {
        if (this._state === AgentState.RUNNING || this._state === AgentState.PAUSED) {
            this._pendingInstruction = instruction;
            if (this._state === AgentState.RUNNING) this._pauseRequested = true;
            return true;
        }
        return false;
    }

    // === Event Handlers ===
    private _onUserCommand(event: Event): void {
        const cmd = event.data.command;
        if (cmd === "pause") this.pause();
        else if (cmd === "resume") this.resume();
        else if (cmd === "stop") this.stop();
    }

    private _onUserInput(event: Event): void {
        const text = event.data.text;
        if (text) this.inject(text);
    }

    // === Main Execution ===
    async run(task: string, resumeSessionId?: string): Promise<any> {
        this._pauseRequested = false;
        this._stopRequested = false;
        this._resumePromise = undefined;

        let session: Session;
        if (resumeSessionId) {
            session = this.sessions.load(resumeSessionId);
            if (!session) return { success: false, error: `Session ${resumeSessionId} not found` };
            if (!task) task = session.task;
        } else {
            session = this.sessions.create({
                target: this.config.target,
                task,
                model: this.config.llm_model,
            });
        }

        if (!this.backend) {
            const { get_ctf_prompt } = await import("pentestgpt/prompts/pentesting");
            this.backend = new ClaudeCodeBackend({
                workingDirectory: this.config.working_directory,
                systemPrompt: get_ctf_prompt(this.config.custom_instruction),
                model: this.config.llm_model,
            });
        }

        try {
            this._setState(AgentState.RUNNING, "Connecting...");

            if (resumeSessionId && this.backend.supportsResume) {
                const backendSession = session.backendSessionId ?? resumeSessionId;
                await this.backend.resume(backendSession);
                this.events.emitMessage(`Resumed session ${resumeSessionId}`, "info");
            } else {
                await this.backend.connect();
            }

            if (this.backend.sessionId) this.sessions.setBackendSessionId(this.backend.sessionId);

            await this.backend.query(task);
            this.sessions.updateStatus(SessionStatus.RUNNING);

            const outputParts: string[] = [];
            const flagsFound: string[] = [];

            for await (const msg of this.backend.receiveMessages()) {
                if (this._stopRequested) {
                    this._setState(AgentState.IDLE, "Stopped by user");
                    this.sessions.updateStatus(SessionStatus.PAUSED);
                    break;
                }

                if (this._pauseRequested) {
                    this._pauseRequested = false;
                    this._setState(AgentState.PAUSED, "Paused - waiting for input");
                    this.sessions.updateStatus(SessionStatus.PAUSED);

                    await new Promise<void>(resolve => (this._resumePromise = { resolve }));
                    this._resumePromise = undefined;

                    if (this._stopRequested) break;

                    this._setState(AgentState.RUNNING, "Resumed");
                    this.sessions.updateStatus(SessionStatus.RUNNING);

                    if (this._pendingInstruction) {
                        this.sessions.addInstruction(this._pendingInstruction);
                        this.events.emitMessage(`Injecting: ${this._pendingInstruction.slice(0, 50)}...`, "info");
                        await this.backend.query(this._pendingInstruction);
                        this._pendingInstruction = undefined;
                    }
                }

                await this._processMessage(msg, outputParts, flagsFound);
            }

            if (!this._stopRequested) {
                this._setState(AgentState.COMPLETED);
                this.sessions.updateStatus(SessionStatus.COMPLETED);
            }

            return {
                success: true,
                output: outputParts.join("\n"),
                flagsFound,
                sessionId: session.sessionId,
                costUsd: session.totalCostUsd,
            };
        } catch (e: any) {
            this._setState(AgentState.ERROR, e.message);
            this.sessions.setError(e.message);
            this.sessions.updateStatus(SessionStatus.ERROR);
            return { success: false, error: e.message };
        } finally {
            if (this.backend) await this.backend.disconnect();
        }
    }

    private async _processMessage(msg: AgentMessage, outputParts: string[], flagsFound: string[]) {
        if (msg.type === MessageType.TEXT) {
            outputParts.push(msg.content);
            this.events.emitMessage(msg.content);

            for (const flag of this._detectFlags(msg.content)) {
                if (!flagsFound.includes(flag)) {
                    flagsFound.push(flag);
                    this.sessions.addFlag(flag, msg.content.slice(0, 200));
                    this.events.emitFlag(flag, msg.content.slice(0, 200));
                }
            }
        } else if (msg.type === MessageType.TOOL_START) {
            this.events.emitTool({
                status: "start",
                name: msg.toolName ?? "unknown",
                args: msg.toolArgs,
            });
        } else if (msg.type === MessageType.TOOL_RESULT) {
            this.events.emitTool({
                status: "complete",
                name: msg.toolName ?? "unknown",
                result: msg.content,
            });
        } else if (msg.type === MessageType.RESULT) {
            const cost = msg.metadata?.costUsd ?? 0;
            if (cost > 0) this.sessions.addCost(cost);
        }
    }

    private _detectFlags(text: string): string[] {
        const flags: string[] = [];
        for (const pattern of AgentController.FLAG_PATTERNS) {
            const matches = text.matchAll(pattern);
            for (const m of matches) {
                const flag = m[0];
                if (!flags.includes(flag)) flags.push(flag);
            }
        }
        return flags;
    }
}

import { AgentBackend, AgentMessage, MessageType } from "./agent-framework"; // Adjust import paths
import {
    ClaudeAgentOptions,
    ClaudeSDKClient,
    AssistantMessage,
    ResultMessage,
    TextBlock,
    ToolUseBlock,
} from "claude-agent-sdk"; // Replace with actual package

export class ClaudeCodeBackend implements AgentBackend {
    private _cwd: string;
    private _systemPrompt: string;
    private _model: string;
    private _permissionMode: string;
    private _client: ClaudeSDKClient | null = null;
    private _sessionId: string | null = null;

    constructor(
        workingDirectory: string,
        systemPrompt: string,
        model: string,
        permissionMode: string = "bypassPermissions"
    ) {
        this._cwd = workingDirectory;
        this._systemPrompt = systemPrompt;
        this._model = model;
        this._permissionMode = permissionMode;
    }

    async connect(): Promise<void> {
        const envOverrides: Record<string, string> = {};
        const authMode = process.env.PENTESTGPT_AUTH_MODE || "manual";

        if (authMode === "manual" && process.env.ANTHROPIC_API_KEY) {
            envOverrides["ANTHROPIC_API_KEY"] = "";
        }

        if (authMode === "openrouter") {
            [
                "ANTHROPIC_BASE_URL",
                "ANTHROPIC_AUTH_TOKEN",
                "NO_PROXY",
                "DISABLE_TELEMETRY",
                "DISABLE_COST_WARNINGS",
                "API_TIMEOUT_MS",
            ].forEach((varName) => {
                const val = process.env[varName];
                if (val) envOverrides[varName] = val;
            });
        }

        const options: ClaudeAgentOptions = {
            cwd: this._cwd,
            permission_mode: this._permissionMode as any, // TODO: fix SDK type
            system_prompt: this._systemPrompt,
            model: this._model,
            env: envOverrides,
        };

        this._client = new ClaudeSDKClient(options);
        const result = this._client.connect();
        if (result) await result;
    }

    async disconnect(): Promise<void> {
        if (this._client) {
            const result = this._client.disconnect();
            if (result) await result;
            this._client = null;
        }
    }

    async query(prompt: string): Promise<void> {
        if (!this._client) throw new Error("Backend not connected");
        const result = this._client.query(prompt);
        if (result) await result;
    }

    async *receiveMessages(): AsyncGenerator<AgentMessage> {
        if (!this._client) throw new Error("Backend not connected");

        for await (const msg of this._client.receive_response()) {
            if (msg instanceof AssistantMessage) {
                for (const block of msg.content) {
                    if (block instanceof TextBlock) {
                        yield {
                            type: MessageType.TEXT,
                            content: block.text,
                        };
                    } else if (block instanceof ToolUseBlock) {
                        yield {
                            type: MessageType.TOOL_START,
                            content: null,
                            tool_name: block.name,
                            tool_args: block.input,
                        };
                    }
                }
            } else if (msg instanceof ResultMessage) {
                yield {
                    type: MessageType.RESULT,
                    content: null,
                    metadata: { cost_usd: (msg as any).total_cost_usd ?? 0 },
                };
            }
        }
    }

    get sessionId(): string | null {
        return this._sessionId;
    }

    get supportsResume(): boolean {
        return true;
    }

    async resume(sessionId: string): Promise<boolean> {
        if (this._client) {
            const result = this._client.disconnect();
            if (result) await result;
        }

        const envOverrides: Record<string, string> = {};
        const authMode = process.env.PENTESTGPT_AUTH_MODE || "manual";

        if (authMode === "manual" && process.env.ANTHROPIC_API_KEY) {
            envOverrides["ANTHROPIC_API_KEY"] = "";
        }

        if (authMode === "openrouter") {
            [
                "ANTHROPIC_BASE_URL",
                "ANTHROPIC_AUTH_TOKEN",
                "NO_PROXY",
                "DISABLE_TELEMETRY",
                "DISABLE_COST_WARNINGS",
                "API_TIMEOUT_MS",
            ].forEach((varName) => {
                const val = process.env[varName];
                if (val) envOverrides[varName] = val;
            });
        }

        const options: ClaudeAgentOptions = {
            cwd: this._cwd,
            permission_mode: this._permissionMode as any,
            system_prompt: this._systemPrompt,
            model: this._model,
            resume: sessionId,
            env: envOverrides,
        };

        this._client = new ClaudeSDKClient(options);
        const result = this._client.connect();
        if (result) await result;
        this._sessionId = sessionId;
        return true;
    }
}


/**********************************************************************************************/

type Backend = {
    connect: () => void;
    disconnect: () => void;
    query: () => void;
    receive_messages: () => void;
    session_id: () => void;
    supportsResume: () => void;
    resume: () => void;
}

type Controller = {
    backend: Backend;
    session_store: SessionStore;
    events: EventBus;
    pause: () => void;
    resume: () => void;
    stop: () => void;
    inject: () => void;
    run: (task: string) => void;
}



const mk_backend = (): Backend => {
    return {
        connect: () => { },
        disconnect: () => { },
        query: () => { },
        receive_messages: () => { },
        session_id: () => { },
        supportsResume: () => { },
        resume: () => { }
    }
}

const mk_controller = (): Controller => {
    let backend = mk_backend();

    let process_msg = (msg: string,) => {

    }
    return {
        backend, session_store: null,
        events: null,
        pause: () => { },
        resume: () => { },
        stop: () => { },
        inject: () => { },
        run: (task: string) => {
            backend.query();
            backend.receive_messages();
        }
    }
}




interface FlagData { flag: string; context: string; }

interface PentestResult {
    success: boolean;
    output: string;
    cost_usd: number;
    flags_found: FlagData[];
    walkthrough: any[];
    session_id: string;
    error?: string;
}



const logger = console;

export async function runPentest(
    target: string,
    customInstruction?: string,
    model?: string,
    workingDir?: string,
    debug: boolean = false,
    resumeSession?: string
): Promise<PentestResult> {
    // Enable verbose logging in debug mode
    if (debug) {
        logger.info("=".repeat(80));
        logger.info("DEBUG MODE ENABLED - CTF CHALLENGE SOLVER");
        logger.info(`Debug log file: ${DEBUG_LOG}`);
        logger.info(`Target: ${target}`);
        if (customInstruction) logger.info(`Challenge context: ${customInstruction}`);
        if (model) logger.info(`Model: ${model}`);
        if (resumeSession) logger.info(`Resuming session: ${resumeSession}`);
        logger.info("=".repeat(80));
    }

    // Build config
    const configArgs: Record<string, any> = { target };
    if (customInstruction) configArgs.custom_instruction = customInstruction;
    if (model) configArgs.llm_model = model;
    if (workingDir) configArgs.working_directory = workingDir;

    const config = loadConfig(configArgs);

    // Build task
    let task = `Solve this CTF challenge and capture the flag(s): ${target}`;
    if (customInstruction) {
        task += `\n\nChallenge context: ${customInstruction}`;
    }

    // Run AgentController
    const controller = new AgentController(config);
    const result: any = await controller.run(task, { resume_session_id: resumeSession });

    // Map result to legacy format
    let finalResult: PentestResult;
    if (result?.success) {
        let flags: FlagData[] = result.flags_found || [];
        if (flags.length > 0 && typeof flags[0] === "string") {
            flags = (flags as string[]).map(f => ({ flag: f, context: "" }));
        }

        finalResult = {
            success: true,
            output: result.output || "",
            cost_usd: result.cost_usd || 0,
            flags_found: flags,
            walkthrough: [],
            session_id: result.session_id || "",
        };
    } else {
        finalResult = {
            success: false,
            output: result?.output || "",
            cost_usd: result?.cost_usd || 0,
            flags_found: [],
            walkthrough: [],
            session_id: result?.session_id || "",
            error: result?.error || "Unknown",
        };
    }

    // Debug logging
    if (debug) {
        logger.info("=".repeat(80));
        logger.info(`CHALLENGE COMPLETE - Success: ${finalResult.success}`);
        if (finalResult.success) {
            logger.info(`Flags found: ${finalResult.flags_found.length}`);
            logger.info(`Cost: $${finalResult.cost_usd.toFixed(4)}`);
            logger.info(`Session: ${finalResult.session_id || "N/A"}`);
            for (const flagData of finalResult.flags_found) {
                logger.info(`  ðŸš© ${flagData.flag}`);
            }
        } else {
            logger.error(`Error: ${finalResult.error}`);
        }
        logger.info("=".repeat(80));
    }

    return finalResult;
}
